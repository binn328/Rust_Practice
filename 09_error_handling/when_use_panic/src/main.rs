// panic!을 언제 사용해야만할까?
// 복구 불가능한 상황에 panic! 을 사용한다.
// 보통 실패할 가능성이 있는 함수는 Result 를 처리해주는 쪽이 좋다.
//
// 몇몇 상황에서는 panic!을 일으키는 쪽이 좋을수도있다.
// 1. 예제, 프로토타입, 테스트의 경우는 panic을 일으켜도 된다!
// 대충 unwrap()으로 만들어두고 나중에 더 견고할 필요가 있을 때
// 이 부분만 손을 봐주면 된다!
//
// 2. 컴파일러보다 내가 더 많은 정보를 가질 때
// 절대 Err이 발생하지 않을것라는 상황이라는 판단이 된다면
// unwrap()을 사용해도 된다!
// 예를 들면 하드코딩된 문자열을 집어넣을 때,
// 사용자의 예상치 못한 입력이 오지 않으므로 절대 Err이 
// 발생하지 않을 것이라고 확신할 수 있다.
// 하지만 사용자의 입력이 온다면, Result를 처리할 필요가 있다.
//
// 코드가 동작할 수 없는 상황일 때, panic!을 일으키면 된다.
// 입력받은 값을 코드가 처리할 수 없는 경우
// 코드가 더이상 동작 불가능한 경우
// 제어권을 벗어난 외부코드를 호출하는데 처리할 수 없는 값을 반환한 경우
// 혹은 보안상으로 어긋나는 접근을 하는 경우 
//
// 수많은 에러처리를 직접하는건 귀찮고 짜증난다.
// 러스트의 타입검사는 이 과정을 대신해줄 수 있다.
//
// 유효성을 위한 커스텀 타입 생성하기
// 1 ~ 100의 값을 입력받기를 원하다면 if문을 사용할 수도 있다.
// 하지만 이는 성능에 영향을 줄 수 있다.
// 차라리 새로운 타입을 만들어서 타입에 유효성검사를 넣을 수 있다.

// 숫자가 저장되는 Guess 타입
pub struct Guess {
    value: u32,
}
impl Guess {
    // new 함수를 구현했다.
    // 숫자를 받아 해당 숫자를 가진 Guess를 반환한다.
    // 규칙에 위배되면 panic을 일으킨다.
    pub fn new(value: u32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}");
        }
        Guess {
            value
        }
    }

    // self를 빌리고 , 파라미터를 가지지 않고, u32를 반환하는 value 함수를 구현
    // getter 함수라고 불린다.
    // Guess 구조체의 내부는 알 수 없기때문에 이런 pub 함수가 필요하다.
    // new 이전에 value를 읽으려한다면 오류가 발생하기에 꼭 필요하다.
    pub fn value(&self) -> u32 {
        self.value
    }
}
fn main() {
    let guess = Guess::new(32);
    println!("{:?}", guess.value());
}
