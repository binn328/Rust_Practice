// Box<T> 는 힙에 있는 데이터를 가리키고 알려진 크기를 가진다.
//
// 다음과 같은 상황에 사용한다.
// 1. 컴파일 타임에 크기를 알 수 없는 타입을 갖고 있고,
//  정확한 사이즈를 알 필요가 있는 맥락 안에서 해당 타입의 값을 이용할때
// 2. 커다란 데이터를 가지고 있고, 소유권을 옮기고 싶지만,
//  그렇게 하면 데이터가 복사되지 않을 것이라고 보장하기를 원할 때
// 3. 어떤 값을 소유하고 이 값의 구체화된 타입을 알고 있기 보다는
//  특정 트레잇을 구현한 타입이라는 점만 신경 쓰고 싶을 때
use List::{Cons, Nil};

fn main() {
    // Box<T>로 힙에 데이터 저장하기
    let b = Box::new(5);
    println!("b = {}", b);

    list();
}

// 컴파일 타임에 정확한 크기를 알 수 없는 타입이 바로 재귀적 타입이다.
// 이론상 무한한 크기를 가질 수 있으므로 러스트는 얼마만큼의 크기가
// 필요한지 알 수 없다.
// 여기에 Box를 사용할 수 있다.
//
// 함수형 언어에서 일반적인 cons list를 알아보자.
// Lisp에서 cons 함수는 두 개의 인자를 받아 한 쌍을 생성한다.
// 재귀의 기본값은 Nil이다.
// 러스트에선 쓰지 않는다.
// 러스트에선 Vec을 쓰는 것이 대부분 더 효과적이다.

enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn list() {
    // 1, 2, 3을 저장하면 다음과 같다.
    // 하지만 현재 컴파일러는 크기를 알 수 없다는 에러를 발생시킨다.
    // Box를 사용하면 포인터 크기만큼만 차지한다는 것을 알 수 있다.
    // 때문에 컴파일러가 오류를 발생시키지않는다.
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}

// Box<T> 타입은 스마트 포인터이다.
// Deref 트레잇을 구현해, Box<T> 값이 참조자처럼 취급된다.
// 또한 스코프를 벗어나면 Box<T>가 가리키는 힙 데이터가 정리된다.
// 이것은 Drop 트레잇을 구현하여 그렇다.
