// 클로저로 환경 캡쳐하기
// 클로저는 함수에 없는 특성이 하나 있다.
// 환경을 캡쳐해서 클로저가 정의된 스코프의 변수들을 접근할 수 있다!
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
    
    // 클로저는 스코프의 변수들에 접근하기 위해 메모리를 사용한다.
    // 함수는 그렇지 않다.
    //
    // 세 가지 방식으로 값을 캡쳐한다.
    // 1. FnOnce -> 클로저가 존재하는 스코프에서 캡처한 변수를 소비한다.
    //              이는 클로저가 소유권을 가져가는 것을 의미한다.
    //              때문에 Once이다. 한번만 호출할 수 있다.
    // 2. Fn -> 환경에서 값을 불변으로 빌려온다.
    // 3. FnMut -> 환경에서 값을 가변으로 빌려온다.
    //              해당 값을 변경할 수 있다.
    //
    // 만약 클로저가 환경에서 사용하는 값에 대해 소유권을 가지도록
    // 강제하고 싶다면, 파라미터 리스트 앞에 move 키워드를 사용할 수 있다.
    // 이 기법은 클로저를 다른 스레드로 넘길 때 소유권까지 넘길 때 사용한다.
    
    let x = vec![1, 2, 3];

    // x의 소유권을 클로저가 가지게 된다.
    // main에서 더이상 x를 사용할 수 없다.
    let equal_to_x = move |z| z == x;

    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}

/*  함수는 이 동작이 불가능 
fn fail_in_fn(z: i32) -> bool { z == x }
*/
